<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: Core ANALYSIS</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('de/d8c/refFrameworkCoreANALYSIS.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Core ANALYSIS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Core ANALYSIS</h2>
<p>This document is WIP and provides an idea of what kind of API to expect from the DPL enabled analysis framework. APIs are neither final nor fully implemented in O2.</p>
<h1>Analysis Task infrastructure on top of DPL</h1>
<p>In order to simplify analysis we have introduced an extension to DPL which allows to describe an Analysis in the form of a collection of AnalysisTask.</p>
<p>In order to create its own task, as user needs to create your own Task deriving from AnalysisTask.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">};</div></div><!-- fragment --><p>such a task can then be added to a workflow via the <code>adaptAnalysisTask</code> helper. <a class="el" href="../../d2/d88/classA.html">A</a> full blown example can be built with:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/dd0/runDataProcessing_8h.html">Framework/runDataProcessing.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d6/d57/AnalysisTask_8h.html">Framework/AnalysisTask.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="../../d9/d61/correlations_8cxx.html#af7d4c4ac874e3b6bf3dcb688a4c64b1b">defineDataProcessing</a>() {</div><div class="line">  <span class="keywordflow">return</span> {</div><div class="line">    adaptAnalysisTask&lt;MyTask&gt;(<span class="stringliteral">&quot;my-task-unique-name&quot;</span>);</div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><blockquote class="doxtable">
<p><b>Implementation details</b>: <code>AnalysisTask</code> is simply a <code>struct</code>. Since <code>struct</code> default inheritance policy is <code>public</code>, we can omit specifying it when declaring MyTask.</p>
<p><code>AnalysisTask</code> will not actually provide any virtual method, as the <code>adaptAnalysis</code> helper relyes on template argument matching to discover the properties of the task. It will come clear in the next paragraph how this allow is used to avoid the proliferation of data subscription methods. </p>
</blockquote>
<h2>Processing data</h2>
<h3>Simple subscriptions</h3>
<p>Once you have an <code>AnalysisTask</code> derived type, the most generic way which you can use to process data is to provide a <code>process</code> method for it.</p>
<p>Depending on the arguments of such a function, you get to iterate on different parts of the AOD content.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(o2::aod::Tracks <span class="keyword">const</span>&amp; tracks) {</div><div class="line">    ...</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>will allow you to get a per timeframe collection of tracks. You can then iterate on the tracks using the syntax:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;track : tracks) {</div><div class="line">  tracks.alpha();</div><div class="line">}</div></div><!-- fragment --><p>Alternatively you can subscribe to tracks one by one via (notice the missing <code>s</code>):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(<a class="code" href="../../d0/d82/namespaceo2_1_1aod.html#ac79ecbd153242801250b9982b0b46664">o2::aod::Track</a> <span class="keyword">const</span>&amp; track) {</div><div class="line">    ...</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>This has the advantage that you might be able to benefit from vectorization / parallelization.</p>
<blockquote class="doxtable">
<p><b>Implementation notes</b>: as mentioned before, the arguments of the process method are inspected using template argument matching. This way the system knows at compile time what data types are requested by a given <code>process</code> method and can create the relevant DPL data descriptions.</p>
<p>The distiction between <code>Tracks</code> and <code>Track</code> above is simply that one refers to the whole collection, while the second is an alias to <code>Tracks::iterator</code>. Notice that we assume that each collection is of type <code><a class="el" href="../../de/dbc/classo2_1_1soa_1_1Table.html">o2::soa::Table</a></code> which carries metadata about the dataOrigin and dataDescription to be used by DPL to subscribe to the associated data stream. </p>
</blockquote>
<h3>Navigating data associations</h3>
<p>For performance reasons, data is organized in a set of flat table and navigation between objects of different tables has to be expressed explicitly in the <code>process</code> method. So if you want to get all the tracks for a specific collision, you will have to implement:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(<a class="code" href="../../d0/d82/namespaceo2_1_1aod.html#afa9eda1d14ea6fd6f8b5442b859ad85f">o2::aod::Collision</a> <span class="keyword">const</span>&amp; collision, o2::aod::Tracks &amp;tracks) {</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --><p>the above will be called once per collision found in the timeframe, and <code>tracks</code> will allow you to iterate on all the tracks associated to the given collision.</p>
<p>Alternatively, you might not require to have all the tracks at once and you could do with:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(o2::aod::Collection <span class="keyword">const</span>&amp; collision, <a class="code" href="../../d0/d82/namespaceo2_1_1aod.html#ac79ecbd153242801250b9982b0b46664">o2::aod::Track</a> <span class="keyword">const</span>&amp; track) {</div><div class="line">}</div></div><!-- fragment --><p>also in this case the advantage is that your code might be up for parallelization and vectorization.</p>
<p>Notice that you are not limited to two different collections, but you could specify more. E.g.:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(o2::aod::Collection <span class="keyword">const</span>&amp; collision, <a class="code" href="../../d0/d82/namespaceo2_1_1aod.html#af95328235e72682338d73eb60e6ac46d">o2::aod::V0</a> <span class="keyword">const</span>&amp; <a class="code" href="../../d4/dc3/classfloat.html">v0</a>, o2::aod::Tracks <span class="keyword">const</span>&amp; tracks) {</div><div class="line">}</div></div><!-- fragment --><p>will be invoked for each v0 associated to a given collision and you will be given the tracks associated to it.</p>
<p>This means that each subsequent argument is associated to all the one preceding it.</p>
<h3>Processing related tables</h3>
<p>For performance reasons, sometimes it's a good idea to split data in separate tables, so that once can request only the subset which is required for a given task. For example, so far the track related information is split in three tables: <code>Tracks</code>, <code>TrackCovs</code>, <code>TrackExtras</code>.</p>
<p>However you might need to get all the information at once. This can be done by asking for a <code>Join</code> table in the process method:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(Join&lt;Tracks, TracksExtras&gt; <span class="keyword">const</span>&amp; mytracks) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; track : mytracks) {</div><div class="line">      <span class="keywordflow">if</span> (track.length()) {  <span class="comment">// from TrackExtras</span></div><div class="line">        tracks.alpha();      <span class="comment">// from Tracks</span></div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2>Creating new collections</h2>
<p>In order to create new collections of objects, you need two things. First of all you need to define a datatype for it, then you need to specify that your analysis task will create such an object. Notice that in a given workflow, only one task is allowed to create a given type of object.</p>
<h3>Introducing a new data type</h3>
<p>In order to define the datatype you need to use <code>DEFINE_SOA_COLUMN</code> and <code>DEFINE_SOA_TABLE</code> helpers, defined in <code>ASoA.h</code>. Assuming you want to extend the standard AOD format you will also need <code>Framework/AnalysisDataModel.h</code>. For example, to define an extra table where to define phi and eta, you first need to define the two columns:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../de/d33/ASoA_8h.html">Framework/ASoA.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/d8c/AnalysisDataModel_8h.html">Framework/AnalysisDataModel.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d0/d82/namespaceo2_1_1aod.html">o2::aod</a> {</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>etaphi {</div><div class="line"><a class="code" href="../../d0/d01/namespaceo2_1_1aod_1_1etaphi.html#af5ad9f0ee6c9fe7453e1254b6257d583">DECLARE_SOA_COLUMN</a>(Eta, eta, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;fEta&quot;</span>);</div><div class="line"><a class="code" href="../../d0/d01/namespaceo2_1_1aod_1_1etaphi.html#af5ad9f0ee6c9fe7453e1254b6257d583">DECLARE_SOA_COLUMN</a>(Phi, phi, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;fPhi&quot;</span>);</div><div class="line">}</div><div class="line">}</div></div><!-- fragment --><p>and then you put them together in a table:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d0/d82/namespaceo2_1_1aod.html">o2::aod</a> {</div><div class="line"><a class="code" href="../../d0/d82/namespaceo2_1_1aod.html#a85a0c9189542829d5810b595122815ae">DECLARE_SOA_TABLE</a>(EtaPhi, <span class="stringliteral">&quot;AOD&quot;</span>, <span class="stringliteral">&quot;ETAPHI&quot;</span>,</div><div class="line">                  etaphi::Eta, etaphi::Phi);</div><div class="line">}</div></div><!-- fragment --><p>Notice that tables are actually just a collections of columns.</p>
<h3>Creating objects for a new data type</h3>
<p>Once you have the new data type defined, you can have a task producing it, by using the <code>Produces</code> helper:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  Produces&lt;o2::aod::EtaPhi&gt; etaphi;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(<a class="code" href="../../d0/d82/namespaceo2_1_1aod.html#ac79ecbd153242801250b9982b0b46664">o2::aod::Track</a> <span class="keyword">const</span>&amp; track) {</div><div class="line">    etaphi(calculateEta(track), calculatePhi(track));</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>the <code>etaphi</code> object is a functor that will effectively act as a cursor which allows to populate the <code>EtaPhi</code> table. Each invokation of the functor will create a new row in the table, using the arguments as contents of the given column. By default the arguments must be given in order, but one can give them in any order by using the correct column type. E.g. in the example above:</p>
<div class="fragment"><div class="line">etaphi(track::Phi(calculatePhi(track), track::Eta(calculateEta(track)));</div></div><!-- fragment --><h3>Adding dynamic columns to a data type</h3>
<p>Sometimes columns are not backed by actual persisted data, but they are merely derived from it. For example you might want to have different representations (e.g. spherical, cylindrical) for a given persisten representation. You can do that by using the <code>DECLARE_SOA_DYNAMIC_COLUMN</code> macro.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>point {</div><div class="line"><a class="code" href="../../de/d33/ASoA_8h.html#a7b9046a69a170ba29c84e132a1bc2a84">DECLARE_SOA_COLUMN</a>(<a class="code" href="../../d8/de9/qconfigoptions_8h.html#a77854b1fceea9fca2fa33736d20fae6a">X</a>, <a class="code" href="../../dc/da3/glcorearb_8h.html#a0cdec8e97a75ee9458b23d152bf962d4">x</a>, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;fX&quot;</span>);</div><div class="line"><a class="code" href="../../de/d33/ASoA_8h.html#a7b9046a69a170ba29c84e132a1bc2a84">DECLARE_SOA_COLUMN</a>(Y, <a class="code" href="../../dc/da3/glcorearb_8h.html#a74d80fd479c0f6d0153c709949a089ef">y</a>, <span class="keywordtype">float</span>, <span class="stringliteral">&quot;fY&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="../../de/d33/ASoA_8h.html#a495a36bab3955b86013ab33be78298de">DECLARE_SOA_DYNAMIC_COLUMN</a>(R2, r2, [](<span class="keywordtype">float</span> <a class="code" href="../../dc/da3/glcorearb_8h.html#a0cdec8e97a75ee9458b23d152bf962d4">x</a>, <span class="keywordtype">float</span> <a class="code" href="../../dc/da3/glcorearb_8h.html#a74d80fd479c0f6d0153c709949a089ef">y</a>) { <span class="keywordflow">return</span> x*x + y+<a class="code" href="../../dc/da3/glcorearb_8h.html#a74d80fd479c0f6d0153c709949a089ef">y</a>; });</div><div class="line"></div><div class="line"><a class="code" href="../../de/d33/ASoA_8h.html#a7ab32f0cc93b1dbaaa35c7ae4903edd1">DECLARE_SOA_TABLE</a>(<a class="code" href="../../d2/dba/CathodeSegmentationLong_8cxx.html#abd1dca17737b73180df12a2aacb067fb">Point</a>, <span class="stringliteral">&quot;MISC&quot;</span>, <span class="stringliteral">&quot;POINT&quot;</span>, <a class="code" href="../../d8/de9/qconfigoptions_8h.html#a77854b1fceea9fca2fa33736d20fae6a">X</a>, Y, (R2&lt;X,Y&gt;));</div></div><!-- fragment --><p>Notice how the dynamic column is defined as a standalone column and binds to X and Y only when you attach it as part of a table.</p>
<h3>Executing a finalisation method, post run</h3>
<p>Sometimes it's handy to perform an action when all the data has been processed, for example executing a fit on a histogram we filled during the processing. This can be done by implementing the postRun method.</p>
<h3>Creating histograms</h3>
<p>New tables are not the only kind on objects you want to create, but most likely you would like to fill histograms associated to the objects you have calculated.</p>
<p>You can do so by using the <code>Histogram</code> helper:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  Histogram etaHisto;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(o2::aod::EtaPhi <span class="keyword">const</span>&amp; etaphi) {</div><div class="line">    etaHisto.fill(etaphi.eta());</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><h1>Creating new columns in a declarative way</h1>
<p>Besides the <code>Produces</code> helper, which allows you to create a new table which can be reused by others, there is another way to define a single column, via the <code>Defines</code> helper.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  Defines&lt;track::Eta&gt; eta = <a class="code" href="../../dc/da3/glcorearb_8h.html#a090ebe65994a3ee4bb60ae3472abffc5">track::alpha</a>;</div><div class="line">};</div></div><!-- fragment --><h2>Filtering and partitioning data</h2>
<p>Given a process function, one can of course define a filter using an if condition:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(o2::aod::EtaPhi <span class="keyword">const</span>&amp; etaphi) {</div><div class="line">    <span class="keywordflow">if</span> (etaphi.phi() &gt; 1 &amp;&amp; etaphi.phi &lt; 1) {</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>however this has the disadvantage that the filtering will be done for every task which has similar or more restrictive conditions. By declaring your filters upfront you can not only simplify your code, but allow the framework to optimize your processing. To do so, we provide two helpers: <code>Filter</code> and <code>Partition</code>.</p>
<h3>Upfront filtering</h3>
<p>The most common kind of filtering is when you process objects only if one of its properties passes a certain criteria. This can be specified with the <code>Filter</code> helper.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  Filter&lt;Tracks&gt; ptFilter = track::pt &gt; 1;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(<a class="code" href="../../df/d41/namespaceo2_1_1framework_1_1readers.html#a3517c3f058c22aff75fe949acd621f13a0640863da55fce25180c704f91e50821">Tracks</a> <span class="keyword">const</span> &amp;filteredTracks) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; track : filteredTracks) {</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>filteredTracks will contain only the tracks in the table which pass the condition <code>track::pt &gt; 1</code>.</p>
<p>You can specify multiple filters which will be applied in a sequence effectively resulting in the intersection of all them.</p>
<p>You can also specify filters on associated quantities:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  Filter&lt;Collisions&gt; collisionFilter = <a class="code" href="../../d8/de9/qconfigoptions_8h.html#a70a779660aad5a4965ee5ada3e6d71bc">max</a>(track::pt) &gt; 1;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(Collsions <span class="keyword">const</span> &amp;filteredCollisions) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; collision: collisions) {</div><div class="line">    ...</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>will process all the collisions which have at least one track with <code>pt &gt; 1</code>.</p>
<h3>Partitioning your inputs</h3>
<p>Filtering is not the only kind of conditional processing one wants to do. Sometimes you need to divide your data in two or more partitions. This is done via the <code>Partition</code> helper:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d0/d82/namespaceo2_1_1aod.html">o2::aod</a>;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  Partition&lt;Tracks&gt; leftTracks = track::eta &lt; 0;</div><div class="line">  Partition&lt;Tracks&gt; rightTracks = track::eta &gt;= 0;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(Tracks <span class="keyword">const</span> &amp;tracks) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="../../dc/da3/glcorearb_8h.html#a85b8f6c07fbc1fb5d77c2ae090f21995">left</a> : leftTracks(tracks)) {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="../../dc/da3/glcorearb_8h.html#a5ffadbbacc6b89cf6218bc43b384d3fe">right</a> : rightTracks(tracks)) {</div><div class="line">        ...</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>i.e. <code>Filter</code> is applied to the objects before passing them to the <code>process</code> method, while <code>Select</code> objects can be used to do further reduction inside the <code>process</code> method itself.</p>
<h3>Filtering and partitioning together</h3>
<p>Of course it should be possible to filter and partition data in the same task. The way this works is that multiple <code>Filter</code>s are logically ANDed together and then they will get anded with the OR of all the <code>Select</code> specified selections.</p>
<h3>Configuring filters</h3>
<p>One of the features of the current framework is the ability to customize on the fly cuts and selection. The idea is to allow that by having a <code>configurable("mnemonic-name-of-the-parameter")</code> helper which can be used to refer to configurable options. The previous example will then become:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyTask : AnalysisTask {</div><div class="line">  Filter&lt;Collisions&gt; collisionFilter = <a class="code" href="../../d8/de9/qconfigoptions_8h.html#a70a779660aad5a4965ee5ada3e6d71bc">max</a>(track::pt) &gt; configurable&lt;float&gt;(<span class="stringliteral">&quot;my-pt-cut&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="../../d8/de9/qconfigoptions_8h.html#abb63a1990038c6375162b39760002a88">process</a>(Collsions <span class="keyword">const</span> &amp;filteredCollisions) {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; collision: collisions) {</div><div class="line">    ...</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><h3>Possible ideas</h3>
<p>We could add a template <code>&lt;typename C...&gt; reshuffle()</code> method to the Table class which allows you to reduce the number of columns or attach new dynamic columns. <a class="el" href="../../d2/d88/classA.html">A</a> template wrapper could even be used to specify if a given dynamic column should be precalculated (or not). This would come handy to optimize the creation of a RowView, which could bind only the required (dynamic) columns. E.g.:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> twoD : points.reshuffle&lt;<a class="code" href="../../d8/de9/qconfigoptions_8h.html#a77854b1fceea9fca2fa33736d20fae6a">point::X</a>, point::Y, Cached&lt;point::R&gt;&gt;()) {</div><div class="line">...</div><div class="line">} </div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d3a/refFramework.html">Module &#39;Framework&#39;</a></li><li class="navelem"><a class="el" href="../../d4/d0b/refFrameworkCore.html">Core</a></li>
    <li class="footer">Generated on Wed Feb 19 2020 20:08:32 for Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
