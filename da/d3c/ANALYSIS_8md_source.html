<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: /home/travis/build/AliceO2Group/AliceO2/Framework/Core/ANALYSIS.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('da/d3c/ANALYSIS_8md.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/travis/build/AliceO2Group/AliceO2/Framework/Core/ANALYSIS.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../da/d3c/ANALYSIS_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;!-- doxy</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;\page refFrameworkCoreANALYSIS Core ANALYSIS</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/doxy --&gt;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;##  Core ANALYSIS</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;This document is WIP and provides an idea of what kind of API to expect from the DPL enabled analysis framework. APIs are neither final nor fully implemented in O2.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;# Analysis Task infrastructure on top of DPL</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;In order to simplify analysis we have introduced an extension to DPL which allows to describe an Analysis in the form of a collection of AnalysisTask.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;In order to create its own task, as user needs to create your own Task deriving from AnalysisTask.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;```cpp</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;};</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;```</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;such a task can then be added to a workflow via the `adaptAnalysisTask` helper. A full blown example can be built with:</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;```cpp</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;#include &quot;Framework/runDataProcessing.h&quot;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;#include &quot;Framework/AnalysisTask.h&quot;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;};</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;defineDataProcessing() {</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  return {</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    adaptAnalysisTask&lt;MyTask&gt;(&quot;my-task-unique-name&quot;);</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  };</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;}</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;```</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;&gt; **Implementation details**: `AnalysisTask` is simply a `struct`. Since `struct` default inheritance policy is `public`, we can omit specifying it when declaring MyTask.</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;&gt;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;&gt; `AnalysisTask` will not actually provide any virtual method, as the `adaptAnalysis` helper relyes on template argument matching to discover the properties of the task. It will come clear in the next paragraph how this allow is used to avoid the proliferation of data subscription methods.   </div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;## Processing data</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;### Simple subscriptions</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Once you have an `AnalysisTask` derived type, the most generic way which you can use to process data is to provide a `process` method for it.</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;Depending on the arguments of such a function, you get to iterate on different parts of the AOD content.</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;For example:</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;```cpp</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  void process(o2::aod::Tracks const&amp; tracks) {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    ...</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  }</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;};</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;```</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;will allow you to get a per timeframe collection of tracks. You can then iterate on the tracks using the syntax:</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;```cpp</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;for (auto &amp;track : tracks) {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  tracks.alpha();</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;```</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;Alternatively you can subscribe to tracks one by one via (notice the missing `s`):</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;```cpp</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  void process(o2::aod::Track const&amp; track) {</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    ...</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  }</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;};</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;```</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;This has the advantage that you might be able to benefit from vectorization / parallelization.</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;&gt; **Implementation notes**: as mentioned before, the arguments of the process method are inspected using template argument matching. This way the system knows at compile time what data types are requested by a given `process` method and can create the relevant DPL data descriptions. </div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;&gt;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;&gt; The distiction between `Tracks` and `Track` above is simply that one refers to the whole collection, while the second is an alias to `Tracks::iterator`.  Notice that we assume that each collection is of type `o2::soa::Table` which carries metadata about the dataOrigin and dataDescription to be used by DPL to subscribe to the associated data stream.</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;### Navigating data associations</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;For performance reasons, data is organized in a set of flat table and navigation between objects of different tables has to be expressed explicitly in the `process` method. So if you want to get all the tracks for a specific collision, you will have to implement:</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;```cpp</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;void process(o2::aod::Collision const&amp; collision, o2::aod::Tracks &amp;tracks) {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;...</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;```</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;the above will be called once per collision found in the timeframe, and `tracks` will allow you to iterate on all the tracks associated to the given collision.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;Alternatively, you might not require to have all the tracks at once and you could do with:</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;```cpp</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;void process(o2::aod::Collection const&amp; collision, o2::aod::Track const&amp; track) {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;}</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;```</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;also in this case the advantage is that your code might be up for parallelization and vectorization.</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;Notice that you are not limited to two different collections, but you could specify more. E.g.: </div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;```cpp</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;void process(o2::aod::Collection const&amp; collision, o2::aod::V0 const&amp; v0, o2::aod::Tracks const&amp; tracks) {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;}</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;```</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;will be invoked for each v0 associated to a given collision and you will be given the tracks associated to it.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;This means that each subsequent argument is associated to all the one preceding it.</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;### Processing related tables</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;For performance reasons, sometimes it&#39;s a good idea to split data in separate tables, so that once can request only the subset which is required for a given task. For example, so far the track related information is split in three tables: `Tracks`, `TrackCovs`, `TrackExtras`.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;However you might need to get all the information at once. This can be done by asking for a `Join` table in the process method:</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;```cpp</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  void process(Join&lt;Tracks, TracksExtras&gt; const&amp; mytracks) {</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    for (auto&amp; track : mytracks) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      if (track.length()) {  // from TrackExtras</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        tracks.alpha();      // from Tracks</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;      }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    }</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  }</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;}</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;```</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;## Creating new collections</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;In order to create new collections of objects, you need two things. First of all you need to define a datatype for it, then you need to specify that your analysis task will create such an object. Notice that in a given workflow, only one task is allowed to create a given type of object.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;### Introducing a new data type</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;In order to define the datatype you need to use `DEFINE_SOA_COLUMN` and `DEFINE_SOA_TABLE` helpers, defined in `ASoA.h`. Assuming you want to extend the standard AOD format you will also need `Framework/AnalysisDataModel.h`. For example, to define an extra table where to define phi and eta, you first need to define the two columns:</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;```cpp</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;#include &quot;Framework/ASoA.h&quot;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;#include &quot;Framework/AnalysisDataModel.h&quot;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;namespace o2::aod {</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;namespace etaphi {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;DECLARE_SOA_COLUMN(Eta, eta, float, &quot;fEta&quot;);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;DECLARE_SOA_COLUMN(Phi, phi, float, &quot;fPhi&quot;);</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;}</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;}</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;```</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;and then you put them together in a table:</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;```cpp</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;namespace o2::aod {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;DECLARE_SOA_TABLE(EtaPhi, &quot;AOD&quot;, &quot;ETAPHI&quot;,</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                  etaphi::Eta, etaphi::Phi);</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;}</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;```</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;Notice that tables are actually just a collections of columns.</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;### Creating objects for a new data type</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;Once you have the new data type defined, you can have a task producing it, by using the `Produces` helper:</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;```cpp</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  Produces&lt;o2::aod::EtaPhi&gt; etaphi;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  void process(o2::aod::Track const&amp; track) {</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    etaphi(calculateEta(track), calculatePhi(track));</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;};</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;```</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;the `etaphi` object is a functor that will effectively act as a cursor which allows to populate the `EtaPhi` table. Each invokation of the functor will create a new row in the table, using the arguments as contents of the given column. By default the arguments must be given in order, but one can give them in any order by using the correct column type. E.g. in the example above:</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;```cpp</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;etaphi(track::Phi(calculatePhi(track), track::Eta(calculateEta(track)));</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;```</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;### Adding dynamic columns to a data type</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;Sometimes columns are not backed by actual persisted data, but they are merely</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;derived from it. For example you might want to have different representations</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;(e.g. spherical, cylindrical) for a given persisten representation. You can</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;do that by using the `DECLARE_SOA_DYNAMIC_COLUMN` macro.</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;```cpp</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;namespace point {</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;DECLARE_SOA_COLUMN(X, x, float, &quot;fX&quot;);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;DECLARE_SOA_COLUMN(Y, y, float, &quot;fY&quot;);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;}</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;DECLARE_SOA_DYNAMIC_COLUMN(R2, r2, [](float x, float y) { return x*x + y+y; });</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;DECLARE_SOA_TABLE(Point, &quot;MISC&quot;, &quot;POINT&quot;, X, Y, (R2&lt;X,Y&gt;));</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;```</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;Notice how the dynamic column is defined as a standalone column and binds to X and Y</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;only when you attach it as part of a table.</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;### Executing a finalisation method, post run</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;Sometimes it&#39;s handy to perform an action when all the data has been processed, for example executing a fit on a histogram we filled during the processing. This can be done by implementing the postRun method.</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;### Creating histograms</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;New tables are not the only kind on objects you want to create, but most likely you would like to fill histograms associated to the objects you have calculated.</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;You can do so by using the `Histogram` helper:</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;```cpp</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  Histogram etaHisto;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  void process(o2::aod::EtaPhi const&amp; etaphi) {</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    etaHisto.fill(etaphi.eta());</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  }</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;};</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;```</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;# Creating new columns in a declarative way</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;Besides the `Produces` helper, which allows you to create a new table which can be reused by others, there is another way to define a single column,  via the `Defines` helper.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;```cpp</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  Defines&lt;track::Eta&gt; eta = track::alpha;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;};</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;```</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;## Filtering and partitioning data</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;Given a process function, one can of course define a filter using an if condition:</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;```cpp</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  void process(o2::aod::EtaPhi const&amp; etaphi) {</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    if (etaphi.phi() &gt; 1 &amp;&amp; etaphi.phi &lt; 1) {</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      ...</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;};</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;```</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;however this has the disadvantage that the filtering will be done for every</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;task which has similar or more restrictive conditions. By declaring your</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;filters upfront you can not only simplify your code, but allow the framework to</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;optimize your processing.  To do so, we provide two helpers: `Filter` and</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;`Partition`. </div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;### Upfront filtering</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;The most common kind of filtering is when you process objects only if one of its</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;properties passes a certain criteria. This can be specified with the `Filter` helper.</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;```cpp</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  Filter&lt;Tracks&gt; ptFilter = track::pt &gt; 1;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  void process(Tracks const &amp;filteredTracks) {</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    for (auto&amp; track : filteredTracks) {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  }</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;};</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;```</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;filteredTracks will contain only the tracks in the table which pass the condition `track::pt &gt; 1`. </div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;You can specify multiple filters which will be applied in a sequence effectively resulting in the intersection of all them.</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;You can also specify filters on associated quantities:</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;```cpp</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  Filter&lt;Collisions&gt; collisionFilter = max(track::pt) &gt; 1;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  void process(Collsions const &amp;filteredCollisions) {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    for (auto&amp; collision: collisions) {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    ...</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    }</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  }</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;};</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;```</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;will process all the collisions which have at least one track with `pt &gt; 1`.</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;### Partitioning your inputs</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;Filtering is not the only kind of conditional processing one wants to do. Sometimes you need to divide your data in two or more partitions. This is done via the `Partition` helper:</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;```cpp</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;using namespace o2::aod;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  Partition&lt;Tracks&gt; leftTracks = track::eta &lt; 0;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  Partition&lt;Tracks&gt; rightTracks = track::eta &gt;= 0;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  void process(Tracks const &amp;tracks) {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    for (auto&amp; left : leftTracks(tracks)) {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      for (auto&amp; right : rightTracks(tracks)) {</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        ...</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;      }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  }</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;};</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;```</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;i.e. `Filter` is applied to the objects before passing them to the `process` method, while `Select` objects can be used to do further reduction inside the `process` method itself. </div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;### Filtering and partitioning together</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;Of course it should be possible to filter and partition data in the same task. The way this works is that multiple `Filter`s are logically ANDed together and then they will get anded with the OR of all the `Select` specified selections.</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;### Configuring filters</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;One of the features of the current framework is the ability to customize on the fly cuts and selection. The idea is to allow that by having a `configurable(&quot;mnemonic-name-of-the-parameter&quot;)` helper which can be used to refer to configurable options. The previous example will then become:</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;```cpp</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;struct MyTask : AnalysisTask {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  Filter&lt;Collisions&gt; collisionFilter = max(track::pt) &gt; configurable&lt;float&gt;(&quot;my-pt-cut&quot;);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;  void process(Collsions const &amp;filteredCollisions) {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    for (auto&amp; collision: collisions) {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    ...</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    }</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  }</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;};</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;```</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;### Possible ideas</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;We could add a template `&lt;typename C...&gt; reshuffle()` method to the Table class which allows you to reduce the number of columns or attach new dynamic columns. A template wrapper could</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;even be used to specify if a given dynamic column should be precalculated (or not). This would come handy to optimize the creation of a RowView, which could bind only the required (dynamic) columns. E.g.:</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;```cpp</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;for (auto twoD : points.reshuffle&lt;point::X, point::Y, Cached&lt;point::R&gt;&gt;()) {</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;...</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;} </div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;```</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../da/d3c/ANALYSIS_8md.html">ANALYSIS.md</a></li>
    <li class="footer">Generated on Wed Feb 19 2020 20:08:24 for Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
